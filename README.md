# Клиент-серверное приложение для демонстрации PoW защиты от DDOS атак

## Постановка задачи

Design and implement “Word of Wisdom” tcp server.
* TCP server should be protected from DDOS attacks with the Prof of Work
(https://en.wikipedia.org/wiki/Proof_of_work), the challenge-response protocol should
be used.
* The choice of the POW algorithm should be explained.
* After Prof Of Work verification, server should send one of the quotes from “word of
wisdom” book or any other collection of the quotes.
* Docker file should be provided both for the server and for the client that solves the
POW challenge.

## Описание используемого challenge-response протокола
С помощью метода интерфейса **POW.GenerateChallenge** генерируется челлендж-строка из 32 рандомных байт.

Далее этот челлендж отправляется клиенту.

Задача клиента - выполнить работу определенной сложности и предоставить доказательство серверу.

Клиент вызывает метод интерфейса **POW.SolveChallenge**. Внутри метода ведется счетчик числа
итераций, и одновременно дополняющая челлендж (суффикс) строка, это nonce.

Вычисляется хэш от связки челлендж+nonce, и если достигнуто оговоренное сервером и клиентом условие (как правило - строковая интерпретация полученного хэша содержит известным обоим сторонам префикс из N нулей) - то задача считается решенной - искомый nonce найден, он отправляется в ответ серверу.

Задача сервера - за минимальное число времени проверить найденный клиентом nonce -
для связки челлендж+nonce вычислить тем же алгоритмом что и клиент(sha256) хэш и проверить,
будет ли выполнено условие (префикс полученной строки совпадает с изначальным).


## Обоснование выбора  POW-алгоритма
Выбор алгоритма для механизма Proof of Work пал на SHA-256. Помимо того факта, что он также используется в сети bitcoin, есть еще доводы:
* SHA-256 является безопасной криптографической хэш-функцией, она устойчива коллизиям и предсказаниям входных данных;

* SHA-256 достаточно быстро работает на современных CPU;

* SHA-256 давно получила широкое распространение, она проверена временем, ее внедрение и проверка не составляет никакого труда для любых клиентов;

* SHA-256 проста в реализации - легко реализуется на различных платформах, что делает ее доступной для внедрения в приложения.


В качестве альтернатив также можно посмотреть на  Ethash(используется в Эфиириуме), но он требует больших затрат по памями, что для клиентской стороны нежелательно.
Еще есть алгоритм Scrypt, используется в Litecoin сети, но он также требует больших затрат по памяти.


## Описание проекта
**bin/** - здесь будут скомпилированные бинарники сервера и клиента;

**internal/** - внутренняя механика приложения;

&nbsp;&nbsp;&nbsp;**internal/pow** - декларация интерфейса POW (методы для генерации челленджа, решения челенджа и проверки результата). Используется как серверной, так и клиенской сторонами. Содержит юнит-тест для проверки ядра кода. Также этот пакет содержит общие настройки для совместной работы клиента и сервера - длина префикса(сложность работы) и размер челленджа;

&nbsp;&nbsp;&nbsp;**internal/verification** - пакет содержит рутину для проверки генерации строки-челленджа,
ее отправки кликету, чтения и проверки результа работы клиента;

&nbsp;&nbsp;&nbsp;**internal/wisdomquotes** - пакет для получения рандомной строки из набора цитат Wisdom;

**server/** - код для запуска TCP сервера и обработчик подключений. Поддерживает переменную окружения _TCP_PORT_ для указания слушаемого порта, а также _READ_TIMEOUT_ для указания таймаута ожидания вычисления nonce клиентом;

**client/** - клиент для подключения к серверу. Поддерживает параметр _addr_ для указания адреса подключения, напр.: _-addr 127.0.0.1:8080_;


Также в корне приложения содержится **Makefile** для быстрого выполнения часто ипользуемых команд, как то - сборка бинарников, запуск линтера;

**.gitlab-ci.yml** gitlab конфигурация для деплоя приложения в k8s кластер;

**.kube** содержит манифесты k8s ресурсов (деплоймент и сервис) для запуска приложения;

**.golangci.yml** содержит конфиг для линтера;

**docker-compose.yml** docker compose файл для запуска контейнера через _make docker-compose-up_;

**Dockerfile** содержит инструкции для сборки образа контейнера, в котором будет работать сервер.



## Запуск приложения
* В корне проекта выполнить команду **make build**. По итогу будут собраны 2 бинарника - для сервера и клиента.
* Запустить сервер: **bin/pow-server**
* В отдельной консоли запустить клиент: **bin/pow-client**. По умолчанию используется порт 8080.


  Connecting to localhost:8080
Please wait while solving challenge...

▹▸▹▹▹  There are two ways of spreading light: to be the candle or the mirror that reflects it.


* если нужно увеличить сложность вычислений, общий для сторон префикс редактируется в файле  _internal/pow/common.go_. После чего нужно пересобрать бинарники.
* если нужно изменить таймаут сервера для чтения nonce клиента - в консоли сервера нужно выполнить команду **export POW_READ_TIMEOUT=1s** и запустить сервер заново.

* чтобы запустить сервер в докере, нужно выполнить команду **make docker-compose-up**. Префикс в образе _kzozulya/pow-app:0.1.0_ равен 00000 - в клиенте он должен быть такой же.